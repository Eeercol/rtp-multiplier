### Ключевая Проблема: "Слепота" Сервиса

Самая большая сложность задачи заключается в том, что **сервис не имеет никакой информации о числах `x` из последовательности клиента**. Он генерирует `multiplier` вслепую.

Это делает невозможным использование простого, **stateless** (не хранящего состояние) подхода с фиксированной вероятностью. 

Результат будет полностью зависеть от данных, о которых сервис ничего не знает.

### Решение: Stateful-Сервис с Саморегуляцией

Чтобы решить проблему "слепоты", нужно сместить фокус. Вместо того чтобы пытаться угадать, как повлиять на итоговый `RTP` клиента, сервис должен **контролировать среднее значение своих собственных генерируемых мультипликаторов**.

Идея в том, что если на длинной дистанции среднее арифметическое всех сгенерированных сервисом мультипликаторов будет равно `rtp`, то и итоговый `RTP` на стороне клиента, независимо от его последовательности, также будет стремиться к `rtp`.

Для этого сервис должен быть **stateful** (хранить состояние). Мы вводим понятие "баланса" (`balance`).

### Математическая Модель

#### Обновление Баланса

После каждого запроса баланс системы обновляется по формуле:

`balance_new = balance_old + rtp - multiplier_generated`

*   `+ rtp`: С каждым вызовом "долг" сервиса увеличивается на целевое значение `rtp`.
*   `- multiplier_generated`: "Долг" уменьшается на фактически "выплаченную" сумму — сгенерированный мультипликатор.

Эта формула создает **систему с отрицательной обратной связью**.

#### Коррекция Вероятности

Теперь нужно использовать `balance` для влияния на генерацию следующего мультипликатора. 

`p_adjusted = p_neutral + k * balance`

*   `k` — это коэффициент чувствительности. 
*   Если `balance > 0` (сервис "в долгу"), `p_adjusted` увеличивается, повышая шанс сгенерировать большой мультипликатор.
*   Если `balance < 0` (сервис "переплатил"), `p_adjusted` уменьшается.
